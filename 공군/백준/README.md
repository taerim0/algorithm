## 2024.12.07 시작

- 2026.06.08 전역 예정

- 문제 타임라인 - 골드 이상만

<details>
<summary>문제 타임라인 24년 12월</summary>      
<table>
  <tr>
    <th scope="col">난이도</td>
    <th scope="col">문제번호 및 제목</td>
    <th scope="col">날짜</td>
    <th scope="col">알고리즘 분류</td>
    <th scope="col">후기</td>
  </tr>
  <tr>
    <td>P5</td>
    <td>1981. 배열에서 이동</td>
    <td>24.12.06</td>
    <td>binary search, DFS</td>
    <td>이분탐색 생각을 못했다.. 많이 틀림</td>
  </tr>
  <tr>
    <td>G5</td>
    <td>2589. 보물섬</td>
    <td>24.12.06</td>
    <td>DFS</td>
    <td>간단한 dfs</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>16434. 드래곤 앤 던전</td>
    <td>24.12.07</td>
    <td>binary search</td>
    <td>게임 하는 것 같아 재밌었다</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>2539. 모자이크</td>
    <td>24.12.08</td>
    <td>binary search</td>
    <td>간단한 이분탐색 응용</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>16472. 고냥이</td>
    <td>24.12.10</td>
    <td>two pointer</td>
    <td>간단한 투포인터. 값 조절 순서 주의</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>1113. 수영장 만들기</td>
    <td>24.12.11</td>
    <td>DFS</td>
    <td>너무 느리게 짬.. 효율적인 풀이 고려해보기.</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>13459. 구슬 탈출</td>
    <td>24.12.13</td>
    <td>BFS</td>
    <td>옛날에 구슬 탈출2 풀었는데 1로 한 번 더 풀기</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>2933. 미네랄</td>
    <td>24.12.19</td>
    <td>BFS</td>
    <td>조금 애먹은 문제.. 코드 수정해서 맞았지만 기존 코드가 왜 WA인지 아직 잘 모르겠다</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>1691. 석판</td>
    <td>24.12.22</td>
    <td>DP</td>
    <td>처음에는 냅색으로 도전하다가 포기하고 재귀응용 DP로 풀이한 문제</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>9328. 열쇠</td>
    <td>24.12.23</td>
    <td>BFS</td>
    <td>0-1 BFS을 베이스로 check 값에다가 비트마스킹을 응용해서 한 번에 푼 뿌듯한 문제 ㅎ</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>18500. 미네랄 2</td>
    <td>24.12.23</td>
    <td>BFS</td>
    <td>미네랄 1에 조건이 하나 붙은 문제. 하지만 동일한 소스코드로 AC</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>4991. 로봇 청소기</td>
    <td>24.12.26</td>
    <td>BFS</td>
    <td>BFS 다 돌리고 거리 저장 후 순열</td>
  </tr>
  <tr>
    <td>G5</td>
    <td>15989. 1, 2, 3 더하기 4</td>
    <td>24.12.29</td>
    <td>DP</td>
    <td>분류가 DP긴 한데 DP보단 수학문제에 가까운 느낌</td>
  </tr>
</table>
</details>

<details>
<summary>문제 타임라인 25년 1월</summary>      
<table>
  <tr>
    <th scope="col">난이도</td>
    <th scope="col">문제번호 및 제목</td>
    <th scope="col">날짜</td>
    <th scope="col">알고리즘 분류</td>
    <th scope="col">한줄평</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>23325. 마법천자문</td>
    <td>25. 01. 11.</td>
    <td>DP</td>
    <td>한 번에 풀긴 했는데 원래 난이도보다 어렵게 푼 느낌..</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>32983. 동굴</td>
    <td>25. 01. 20.</td>
    <td>BFS</td>
    <td>젤다의 전설</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>2042. 구간 합 구하기</td>
    <td>25. 01. 31.</td>
    <td>segment tree</td>
    <td>휴머니스트 wiki 게시판에서 세그트리 배우고 써먹은 문제</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>11505. 구간 곱 구하기</td>
    <td>25. 01. 31.</td>
    <td>segment tree</td>
    <td>위 문제를 곱셈 연산으로 바꾼 문제. 쿼리 출력 방법에 주의</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>2357. 최솟값과 최댓값</td>
    <td>25. 01. 31.</td>
    <td>segment tree</td>
    <td>세그먼트 트리를 pair 자료형으로 응용. 업데이트 없는 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>10868. 최솟값</td>
    <td>25. 01. 31.</td>
    <td>segment tree</td>
    <td>위 문제의 더 쉬운 버전! int 자료형으로 해결</td>
  </tr>
</table>
</details>

<details>
<summary>문제 타임라인 25년 2월</summary>      
<table>
  <tr>
    <th scope="col">난이도</td>
    <th scope="col">문제번호 및 제목</td>
    <th scope="col">날짜</td>
    <th scope="col">알고리즘 분류</td>
    <th scope="col">한줄평</td>
  </tr>
  <tr>
    <td>P5</td>
    <td>1725. 히스토그램</td>
    <td>25. 02. 01.</td>
    <td>segment tree, stack, divide and conquer</td>
    <td>이전에 분할정복으로 풀었던 문제인데 세그트리로 다시 풀어봤다</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>2268. 수들의 합 7</td>
    <td>25. 02. 01.</td>
    <td>segment tree</td>
    <td>세그트리 기본문제. 지문에 주의..</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>1275. 커피숍2</td>
    <td>25. 02. 17.</td>
    <td>segment tree</td>
    <td>공부 너무 안했다..... 복기 겸 세그트리 기본문제</td>
  </tr>
  <tr>
    <td>P5</td>
    <td>1321. 군인</td>
    <td>25. 02. 17.</td>
    <td>segment tree</td>
    <td>세그먼트 트리 쿼리 변형 응용. 누적합에서 타겟 값보다 큰 값들 중 최솟값의 위치를 찾아내면 됨</td>
  </tr>
  <tr>
    <td>G3</td>
    <td>28099. 이상한 배열</td>
    <td>25. 02. 27.</td>
    <td>segment tree</td>
    <td>최댓값 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>18436. 수열과 쿼리 37</td>
    <td>25. 02. 27.</td>
    <td>segment tree</td>
    <td>pair 사용해서 짝수, 홀수 카운팅 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>14438. 수열과 쿼리 17</td>
    <td>25. 02. 27.</td>
    <td>segment tree</td>
    <td>최솟값 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>12837. 가계부(Hard)</td>
    <td>25. 02. 27.</td>
    <td>segment tree</td>
    <td>init 없는 8byte 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>14428. 수열과 쿼리 16</td>
    <td>25. 02. 28.</td>
    <td>segment tree</td>
    <td>pair 사용해서 최솟값의 인덱스 세그트리</td>
  </tr>
  <tr>
    <td>G1</td>
    <td>14427. 수열과 쿼리 15</td>
    <td>25. 02. 28.</td>
    <td>segment tree</td>
    <td>위 문제와 큰 차이 없음. 엄...</td>
  </tr>
  <tr>
    <td>P5</td>
    <td>2104. 부분 배열 고르기</td>
    <td>25. 02. 28.</td>
    <td>segment tree, stack, divide and conquer</td>
    <td>히스토그램류 문제인데 세그트리로 풀어보기</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>11559. Puyo Puyo</td>
    <td>25. 02. 28.</td>
    <td>BFS, simulation</td>
    <td></td>
  </tr>
</table>
</details>

<details>
<summary>문제 타임라인 25년 3월</summary>      
<table>
  <tr>
    <th scope="col">난이도</td>
    <th scope="col">문제번호 및 제목</td>
    <th scope="col">날짜</td>
    <th scope="col">알고리즘 분류</td>
    <th scope="col">한줄평</td>
  </tr>
  <tr>
    <td>P5</td>
    <td>5676. 음주 코딩</td>
    <td>25. 03. 03.</td>
    <td>segment tree</td>
    <td>EOF 입력 곱셈 세그먼트 트리 << 실수할 거리 많음..</td>
  </tr>
  <tr>
    <td>G4</td>
    <td>14226. 이모티콘</td>
    <td>25. 03. 03.</td>
    <td>BFS</td>
    <td>2차원 check 배열 사용하는 아이디어가 재밌음.</td>
  </tr>
      
</table>
</details>